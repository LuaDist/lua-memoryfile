.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LUA-MEMORYFILE 3"
.TH LUA-MEMORYFILE 3 "2008-04-19" "1.1" "In-memory file handles for Lua"
.SH "Name"
.IX Header "Name"
Lua-MemoryFile \- Lua 5.1 module for in-memory simulated file I/O
.SH "Description"
.IX Header "Description"
The module allows Lua programs to open strings like files for reading
and writing.  This can be useful for various reasons:
.IP "\(bu" 4
Treat a memoryfile object like a stringbuffer, writing things on to the end
of it rather than concatenating lots of strings (which can be slow in Lua).
.IP "\(bu" 4
Read text from a string a line at a time.
.IP "\(bu" 4
Use this instead of temporary files for testing, or for when another module
requires a file handle to operate on but you'd rather give it a string
.SH "Loading the module"
.IX Header "Loading the module"
The MemoryFile module doesn't install itself into any global tables, so you can
decide what name you want to use to access it.  You will probably want to
load it like this:
.PP
.Vb 1
\&    local MemFile = require "memoryfile"
.Ve
.PP
You can use a variable called something other than \f(CW\*(C`MemFile\*(C'\fR if you'd like,
or you could assign the table returned by \f(CW\*(C`require\*(C'\fR to a global variable.
In this documentation we'll assume you're using a variable called \f(CW\*(C`MemFile\*(C'\fR.
.SH "Simulating a mutable string"
.IX Header "Simulating a mutable string"
This is probably the most useful way of using the MemoryFile module.  You
want to create a string from lots of individual pieces (perhaps you're
adding values from an array, or serializing a tree structure like a set
of nested tables or an \s-1XML\s0 \s-1DOM\s0).
.PP
Here's an example which turns a table of strings into a single string of
Lua source code:
.PP
.Vb 2
\&    local code = MemFile.open(nil, "w")
\&    local strings = { "foo", "bar", "quux" }
.Ve
.PP
.Vb 4
\&    code:write("values = {\en")
\&    for _, value in ipairs(strings) do
\&        code:write("    ", string.format("%q", value), ",\en")
\&    end
.Ve
.PP
.Vb 1
\&    code:write("}\en")
.Ve
.PP
.Vb 2
\&    local code_string = tostring(code)
\&    code:close()
.Ve
.PP
Of course this would only be useful if the \f(CW\*(C`strings\*(C'\fR table in the example
was a lot larger, but in that case it would be much faster to write all
the individual strings to a MemoryFile handle than to concatenate them all
onto a Lua string.
.PP
At the end of the example above we use \f(CW\*(C`tostring\*(C'\fR to get the content of the
memory file as a normal Lua string.  The example also uses the \f(CW\*(C`close\*(C'\fR method
to clear out the data from the file handle, which is a good idea after you're
finished with it, because it frees up memory immediately rather than waiting
for the Lua garbage collector to get around to doing it for you.
.SH "Creating file handles"
.IX Header "Creating file handles"
The table returned by \f(CW\*(C`require\*(C'\fR contains a single function, \f(CW\*(C`open\*(C'\fR.
This takes up to two arguments.  The first (what would be the filename for
\&\f(CW\*(C`io.open\*(C'\fR) is a string used to initialize the file handle.  If it is nil
or the empty string then the memory file will be empty to start with, otherwise
it will contain some data which can be read with the \f(CW\*(C`read\*(C'\fR method.
.PP
Note that since Lua strings are immutable, MemoryFile always makes a copy of
the string data you initialize it with, so the original string will not be
affected by changes to the file's data.
.PP
The second argument to \f(CW\*(C`open\*(C'\fR is a mode string.  The first character should
be \f(CW\*(C`r\*(C'\fR, \f(CW\*(C`w\*(C'\fR, or \f(CW\*(C`a\*(C'\fR.  The default is \f(CW\*(C`r\*(C'\fR.  The read and write modes are
actually the same.  Whichever you use, you can read or write with the file
handle.  In append mode reading and writing will also work the same as normal,
except that anything you write on to the file will go at the end of the file,
regardless of where you have positioned the file with \f(CW\*(C`seek\*(C'\fR.
.PP
Any extra characters in the mode string will be ignored, so the \f(CW\*(C`+\*(C'\fR and
\&\f(CW\*(C`b\*(C'\fR flags will have no affect.
.SH "File handle methods"
.IX Header "File handle methods"
Most of these methods behave basically the same way as the ones provided
by Lua's real file handles.  See the Lua reference manual for details:
.PP
<http://www.lua.org/manual/5.1/manual.html#5.7>
.IP "close" 4
.IX Item "close"
This frees up any resources associated with the file handle, and resets it
to contain zero bytes of data.  This is identical to calling \f(CWsize(0)\fR on
a memoryfile handle.  Unlike real file handles, you can continue to use
a memoryfile after it has been reset in this way.
.Sp
Always returns \f(CW\*(C`true\*(C'\fR.
.IP "flush" 4
.IX Item "flush"
.PD 0
.IP "setvbuf" 4
.IX Item "setvbuf"
.PD
These two functions do nothing, and are merely provided for compatibility
with real Lua file handles.  They always return \f(CW\*(C`true\*(C'\fR.
.IP "lines" 4
.IX Item "lines"
Returns an iterator for looping over the lines in the buffer, starting
from the current position seeked to.  This example counts the lines in
the string by iterating over them:
.Sp
.Vb 4
\&    local f = MemFile.open("foo\enbar\enbaz\en")
\&    local count = 0
\&    for line in f:lines() do count = count + 1 end
\&    print("number of lines in string:", count)
.Ve
.Sp
Each line will be read as if by \f(CW\*(C`read("*l")\*(C'\fR, so the strings will not
include the newline character.
.IP "read" 4
.IX Item "read"
Read some data from the file handle's buffer.  Does everything the standard
version does.  Can be used to read fixed-size pieces of data from the
buffer:
.Sp
.Vb 2
\&    local f = MemFile.open("foobarbaz")
\&    local foo, barbaz = f:read(3, 6)
.Ve
.Sp
or to get a number value from a string:
.Sp
.Vb 2
\&    local f = MemFile.open("23.25")
\&    local num = f:read("*n")
.Ve
.Sp
or to read lines, or the whole of the rest of the file:
.Sp
.Vb 3
\&    local f = MemFile.open("foo\enbar\enetc...")
\&    local line1, line2 = f:read("*l", "*l")
\&    local rest = f:read("*a")
.Ve
.IP "seek" 4
.IX Item "seek"
Same as the version for normal Lua file handles.  You give it a string
indicating where to start from (\f(CW\*(C`set\*(C'\fR, \f(CW\*(C`cur\*(C'\fR, or \f(CW\*(C`end\*(C'\fR), and
a number indicating how many bytes to move relative to that.  It moves
the position for the next read or write operation to that point, and
returns the number of bytes from the start of the buffer that is.
.Sp
Note that the position you seek to will be ignored for writing when the
file handle was opened in \f(CW\*(C`a\*(C'\fR (for append) mode.  In that case all
writes will go at the end of the file, but you can still use \f(CW\*(C`seek\*(C'\fR to
read from other places.
.Sp
The arguments default to \f(CW\*(C`cur\*(C'\fR and zero, so if you call \f(CW\*(C`seek\*(C'\fR without
any arguments it will leave the buffer position unchanged.  You can use
that if you just want to find out where in the buffer you are:
.Sp
.Vb 9
\&    \-\- Get a byte from a certain position, then restore
\&    \-\- the original seek position.
\&    function get_byte (f, position)
\&        local old_position = f:seek()
\&        f:seek("set", position)
\&        local byte = f:read(1)
\&        f:seek("set", old_position)
\&        return byte
\&    end
.Ve
.Sp
To jump right to the end of a file so that you can write some more data
after what already exists in the buffer:
.Sp
.Vb 1
\&    f:seek("end")
.Ve
.Sp
\&\f(CW\*(C`seek\*(C'\fR returns nil and an error message if you try to seek to after the
end of the current buffer.
.IP "size" 4
.IX Item "size"
Returns the number of bytes which are currently stored in the buffer.  This
is the same as the length of the string which will be returned by passing
the file handle to \f(CW\*(C`tostring\*(C'\fR.
.Sp
Giving \f(CW\*(C`size\*(C'\fR an argument will cause it to \fIset\fR the size as well as return
the previous size.  It can be used to truncate the file handle's buffer to a
certain number of bytes long, or to extend a file without having to write
any data into it.  Any new data which appears after \f(CW\*(C`size\*(C'\fR makes a buffer
bigger will be initialized to have all null (zero) bytes.
.Sp
Calling \f(CWsize(0)\fR will free up the buffer and reset the handle to the empty
string.  This can be used when work with a file handle is finished, so that
a potentially large memory buffer isn't left on the heap until the garbage
collector gets round to freeing it.  This is exactly the same as calling the
\&\f(CW\*(C`close()\*(C'\fR method.
.IP "write" 4
.IX Item "write"
Copies the data from its arguments, which must be strings or numbers, into
the buffer for a MemoryFile handle.  The values are added one after another,
with nothing in between.
.Sp
After calling \f(CW\*(C`write\*(C'\fR the seek position will be moved to the end of the
newly written data, except in append mode, when it will be left where it is.
.Sp
If you use \f(CW\*(C`seek\*(C'\fR, or open a file with some initial data, you can use write
to overwrite data already in the buffer.  It will still make the buffer bigger
if it needs more room, and it will never shrink the buffer.  Also, if the
MemoryFile handle was opened in append mode then \f(CW\*(C`write\*(C'\fR will ignore the
position you seeked to and write all new data onto the end of the buffer.
.IP "_\|_tostring" 4
.IX Item "__tostring"
You can use the Lua \f(CW\*(C`tostring\*(C'\fR function to get a string copy of the current
data in a MemoryFile handle:
.Sp
.Vb 3
\&    local f = MemFile.open("foo")
\&    for i = 1, 10 do f:write(tostring(f)) end
\&    print(f)
.Ve
.SH "Differences from real file handles"
.IX Header "Differences from real file handles"
The userdata objects returned from MemoryFile's \f(CW\*(C`open\*(C'\fR function are
intended to be fairly compatible with the file handles returned by Lua's
standard \f(CW\*(C`io.open\*(C'\fR function.  There are some differences in how they
behave though.
.IP "\(bu" 4
Opening a file in \f(CW\*(C`w\*(C'\fR or \f(CW\*(C`a\*(C'\fR mode doesn't truncate it.  If you want to
start with an empty file, just be sure to pass nil or the empty string to
\&\f(CW\*(C`open\*(C'\fR as the initial data.
.IP "\(bu" 4
Reading and writing both work regardless of what mode was given to \f(CW\*(C`open\*(C'\fR.
.IP "\(bu" 4
The \f(CW\*(C`size\*(C'\fR method provided by this module is not provided by standard Lua
file handles, which don't offer any facility for reducing the size of an
existing file (other than writing over it with a new one).
.IP "\(bu" 4
Some filesystems will allow you to create a large file by seeking past the
end of the data that already exists and then writing data where you want
the file to end.  The memoryfile \f(CW\*(C`seek\*(C'\fR method however will refuse to seek
past the end of the existing data.  You can use the \f(CW\*(C`size\*(C'\fR method instead
to create a file of a certain size.
.SH "Copyright"
.IX Header "Copyright"
This software and documentation is Copyright (c) 2007 Geoff Richards
<geoff@laxan.com>.  It is free software; you can redistribute it
and/or modify it under the terms of the Lua\ 5.0 license.  The full terms
are given in the file \fI\s-1COPYRIGHT\s0\fR supplied with the source code package,
and are also available here: <http://www.lua.org/license.html>
